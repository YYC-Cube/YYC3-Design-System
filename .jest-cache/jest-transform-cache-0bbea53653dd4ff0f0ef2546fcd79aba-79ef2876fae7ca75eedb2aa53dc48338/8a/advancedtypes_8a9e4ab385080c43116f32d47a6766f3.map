{"version":3,"names":["cov_13y1z7m9ai","path","hash","global","Function","gcv","coverageData","statementMap","start","line","column","end","fnMap","branchMap","s","f","b","inputSourceMap","file","mappings","names","sources","sourcesContent","version","_coverageSchema","coverage","actualCoverage"],"sources":["/Users/yanyu/Downloads/yyc3-Design-System/src/types/advanced-types.ts"],"sourcesContent":["/**\n * @file 高级类型定义\n * @description 提供严格的类型约束和高级类型工具\n * @module types/advanced-types\n * @author YYC³\n * @version 1.0.0\n * @created 2026-02-19\n */\n\nimport type { ElementType } from 'react';\nimport * as React from 'react';\n\nexport type DesignTokens = {\n  colors: Record<string, string>;\n  spacing: Record<string, string>;\n  typography: Record<string, unknown>;\n  radius: Record<string, string>;\n  shadows: Record<string, string>;\n  animations: Record<string, string>;\n  breakpoints: Record<string, string>;\n};\n\nexport type OmitNever<T> = Omit<T, never>;\n\nexport type StrictOmit<T, K extends keyof T> = T & OmitNever<Pick<T, K>>;\n\nexport type StrictPick<T, K extends keyof T> = Pick<T, K>;\n\nexport type Merge<T, U> = Omit<T, keyof U> & U;\n\nexport type PolymorphicComponentProps<E extends ElementType, P extends object = object> = P & {\n  as?: E;\n  children?: React.ReactNode;\n};\n\nexport type ComponentWithRef<\n  T extends ElementType,\n  P extends object = object,\n> = React.ForwardRefExoticComponent<PolymorphicComponentProps<T, P>>;\n\nexport type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };\n\nexport type WithOptional<T, K extends keyof T> = Omit<T, K> & { [P in K]?: T[P] };\n\nexport type Nullable<T> = T | null;\n\nexport type Optional<T> = T | undefined;\n\nexport type MaybePromise<T> = T | Promise<T>;\n\nexport type AsyncReturnType<T extends (...args: unknown[]) => unknown> = T extends (\n  ...args: unknown[]\n) => Promise<infer U>\n  ? U\n  : T extends (...args: unknown[]) => infer U\n    ? U\n    : unknown;\n\nexport type NonEmptyArray<T> = [T, ...T[]];\n\nexport type ValueOf<T> = T[keyof T];\n\nexport type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\nexport type RequiredBy<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;\n\nexport type UnionToIntersection<U> = (U extends unknown ? (k: U) => void : never) extends (\n  k: infer I\n) => void\n  ? I & { [K in keyof I]: I[K] }\n  : never;\n\nexport type LastOf<T extends unknown[]> = T extends [...unknown[], infer L] ? L : never;\n\nexport type FirstOf<T extends unknown[]> = T extends [infer F, ...unknown[]] ? F : never;\n\nexport type TupleToUnion<T extends unknown[]> = T[number];\n\nexport type IsAny<T> = unknown extends T ? ([T] extends [never] ? false : true) : false;\n\nexport type IsNever<T> = [T] extends [never] ? true : false;\n\nexport type IsUnknown<T> = unknown extends T ? ([T] extends [never] ? false : true) : false;\n\nexport type IsUnion<T, U extends T = T> = (T extends U ? false : true) extends false ? false : true;\n\nexport type Equals<X, Y> =\n  (<T>() => T extends X ? (Y extends X ? true : false) : false) extends <T>() => T extends Y\n    ? Y extends X\n      ? true\n      : false\n    : false\n    ? true\n    : false;\n\nexport type Brand<K, T> = T & { readonly __brand: K };\n\nexport type Unbrand<T> = T extends { readonly __brand: unknown } ? T : never;\n\nexport type BrandedColor = Brand<'Color', string>;\n\nexport type BrandedSpacing = Brand<'Spacing', string>;\n\nexport type ColorValue = string | BrandedColor;\n\nexport type CSSValue = string | number;\n\nexport type ResponsiveValue<T> = T | (T | Responsive<T>)[];\n\nexport type Responsive<T> = {\n  xs?: T;\n  sm?: T;\n  md?: T;\n  lg?: T;\n  xl?: T;\n};\n\nexport type SpacingValue = string | number;\n\nexport type ThemeValue<T> = T | ((theme: DesignTokens) => T);\n\nexport type AnimationDefinition = {\n  name: string;\n  duration?: string;\n  timing?: string;\n  delay?: string;\n  iteration?: string;\n  direction?: string;\n  fill?: string;\n  playState?: string;\n};\n\nexport type CSSProperties = React.CSSProperties & {\n  [key: string]: unknown;\n};\n\nexport type VariantProps<V extends string> = {\n  variant?: V;\n};\n\nexport type ColorProps = {\n  color?: ColorValue;\n  backgroundColor?: ColorValue;\n  borderColor?: ColorValue;\n};\n\nexport type SpacingProps = {\n  margin?: SpacingValue | ResponsiveValue<SpacingValue>;\n  padding?: SpacingValue | ResponsiveValue<SpacingValue>;\n  gap?: SpacingValue | ResponsiveValue<SpacingValue>;\n};\n\nexport type LayoutProps = {\n  width?: CSSValue | ResponsiveValue<CSSValue>;\n  height?: CSSValue | ResponsiveValue<CSSValue>;\n  display?: CSSValue;\n  flex?: CSSValue;\n  flexDirection?: CSSValue;\n  justifyContent?: CSSValue;\n  alignItems?: CSSValue;\n};\n\nexport type TypographyProps = {\n  fontSize?: CSSValue | ResponsiveValue<CSSValue>;\n  fontWeight?: CSSValue;\n  lineHeight?: CSSValue;\n  letterSpacing?: CSSValue;\n  textAlign?: CSSValue;\n};\n\nexport type WithAsProp<T extends ElementType> = {\n  as?: T;\n};\n\nexport type WithoutRef<T> = Omit<T, 'ref'>;\n\nexport type WithRef<T> = T & { ref?: React.Ref<unknown> };\n\nexport type ForwardRefComponent<T, P> = React.ForwardRefExoticComponent<P & React.RefAttributes<T>>;\n\nexport type HTMLAttributes<T extends ElementType> = React.ComponentPropsWithoutRef<T>;\n\nexport type EventHandler<E extends React.SyntheticEvent<unknown, unknown>> = (event: E) => void;\n\nexport type ChangeHandler = EventHandler<React.ChangeEvent<Element>>;\n\nexport type FocusHandler = EventHandler<React.FocusEvent<Element>>;\n\nexport type KeyboardHandler = EventHandler<React.KeyboardEvent<Element>>;\n\nexport type MouseHandler = EventHandler<React.MouseEvent<Element>>;\n\nexport type TouchHandler = EventHandler<React.TouchEvent<Element>>;\n\nexport type ARIAAttributes = {\n  'aria-label'?: string;\n  'aria-labelledby'?: string;\n  'aria-describedby'?: string;\n  'aria-hidden'?: boolean;\n  'aria-disabled'?: boolean;\n  'aria-expanded'?: boolean;\n  'aria-pressed'?: boolean;\n  'aria-selected'?: boolean;\n  'aria-checked'?: boolean;\n  'aria-invalid'?: boolean;\n  'aria-required'?: boolean;\n  'aria-live'?: 'polite' | 'assertive' | 'off';\n  'aria-atomic'?: boolean;\n  'aria-busy'?: boolean;\n  'aria-controls'?: string;\n  'aria-current'?: boolean | 'page' | 'step' | 'location' | 'date' | 'time';\n  'aria-haspopup'?: boolean | 'listbox' | 'menu' | 'tree' | 'grid' | 'dialog';\n};\n\nexport type DataAttributes = {\n  'data-testid'?: string;\n  'data-cy'?: string;\n  'data-qa'?: string;\n  [key: `data-${string}`]: unknown;\n};\n\nexport type EventHandlers = {\n  onClick?: MouseHandler;\n  onDoubleClick?: MouseHandler;\n  onMouseDown?: MouseHandler;\n  onMouseUp?: MouseHandler;\n  onMouseEnter?: MouseHandler;\n  onMouseLeave?: MouseHandler;\n  onMouseMove?: MouseHandler;\n  onFocus?: FocusHandler;\n  onBlur?: FocusHandler;\n  onKeyDown?: KeyboardHandler;\n  onKeyUp?: KeyboardHandler;\n  onChange?: ChangeHandler;\n  onSubmit?: EventHandler<React.FormEvent<HTMLFormElement>>;\n  onReset?: EventHandler<React.FormEvent<HTMLFormElement>>;\n};\n\nexport type CommonProps = ColorProps &\n  SpacingProps &\n  LayoutProps &\n  TypographyProps &\n  ARIAAttributes &\n  DataAttributes &\n  EventHandlers & {\n    id?: string;\n    className?: string;\n    style?: React.CSSProperties;\n    children?: React.ReactNode;\n    role?: string;\n    tabIndex?: number;\n    disabled?: boolean;\n    hidden?: boolean;\n  };\n\nexport type ElementTypeType = React.ElementType;\n\nexport type ComponentType<P = unknown> = React.ComponentType<P>;\n\nexport type ReactElement = React.ReactElement;\n\nexport type ReactNode = React.ReactNode;\n\nexport type Ref<T> = React.Ref<T>;\n\nexport type RefCallback<T> = (instance: T | null) => void;\n\nexport type MutableRefObject<T> = React.MutableRefObject<T>;\n\nexport type ComponentPropsType<T extends ElementType> = React.ComponentPropsWithoutRef<T>;\n\nexport type PolymorphicRef<T extends ElementType> = React.ComponentPropsWithRef<T>['ref'];\n\nexport type ExtractProps<T> = T extends React.ComponentType<infer P> ? P : never;\n\nexport type MergeProps<T, U> = Omit<T, keyof U> & U;\n\nexport type OverrideProps<T, O> = Omit<T, keyof O> & Partial<O>;\n\nexport type OverrideComponentProps<T, O> = T & O;\n\nexport type DefaultProps<T, P extends keyof T> = Omit<T, P> & { [K in P]?: T[K] };\n\nexport type ExtractComponentType<T> = T extends React.ComponentType<infer P> ? P : never;\n\nexport type Prettify<T> = {\n  [K in keyof T]: T[K];\n};\n\nexport type DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\n};\n\nexport type DeepRequired<T> = {\n  [P in keyof T]-?: T[P] extends object ? DeepRequired<T[P]> : Required<T[P]>;\n};\n\nexport type DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];\n};\n\nexport type DeepMutable<T> = {\n  -readonly [P in keyof T]: T[P] extends object ? DeepMutable<T[P]> : T[P];\n};\n\nexport type Exact<T, Shape> = [Shape] extends [T] ? [T] : never;\n\nexport type Widen<T> = T extends string\n  ? string\n  : T extends number\n    ? number\n    : T extends boolean\n      ? boolean\n      : T extends null\n        ? null\n        : T extends undefined\n          ? undefined\n          : T;\n\nexport type Narrow<T> = T extends string\n  ? string\n  : T extends number\n    ? number\n    : T extends boolean\n      ? boolean\n      : T extends null\n        ? null\n        : T extends undefined\n          ? undefined\n          : T;\n\nexport type NonNullable<T> = T extends null | undefined ? never : T;\n\nexport type NonUndefined<T> = T extends undefined ? never : T;\n\nexport type NonNull<T> = T extends null ? never : T;\n\nexport type DeepNonNullable<T> = {\n  [P in keyof T]: NonNullable<T[P]>;\n};\n\nexport type DeepNonUndefined<T> = {\n  [P in keyof T]: NonUndefined<T[P]>;\n};\n\nexport type DeepNonNull<T> = {\n  [P in keyof T]: NonNull<T[P]>;\n};\n\nexport type PickRequired<T, K extends keyof T> = Required<Pick<T, K>>;\n\nexport type PickOptional<T, K extends keyof T> = Partial<Pick<T, K>>;\n\nexport type OmitUndefined<T> = {\n  [K in keyof T as undefined extends T[K] ? never : K]: T[K];\n};\n\nexport type OmitNull<T> = {\n  [K in keyof T as null extends T[K] ? never : K]: T[K];\n};\n\nexport type KeysOfType<T, U> = {\n  [K in keyof T]-?: T[K] extends U ? K : never;\n}[keyof T];\n\nexport type ValuesOfType<T, U> = Pick<T, KeysOfType<T, U>>[keyof Pick<T, KeysOfType<T, U>>];\n\nexport type ArrayElement<T> = T extends readonly (infer U)[] ? U : never;\n\nexport type TupleElement<T extends readonly unknown[]> = T[number];\n\nexport type Head<T extends unknown[]> = T extends [infer H, ...unknown[]] ? H : never;\n\nexport type Tail<T extends unknown[]> = T extends [...unknown[], infer L] ? L : never;\n\nexport type Length<T extends unknown[]> = T extends { length: infer L } ? L : never;\n\nexport type Append<T extends unknown[], U> = [...T, U];\n\nexport type Prepend<T extends unknown[], U> = [U, ...T];\n\nexport type Shift<T extends unknown[]> = T extends [unknown, ...infer R] ? R : never;\n\nexport type Unshift<T extends unknown[], U> = T extends [...infer R, unknown] ? [U, ...R] : never;\n\nexport type Pop<T extends unknown[]> = T extends [...infer R, unknown] ? R : never;\n\nexport type Push<T extends unknown[], U> = [...T, U];\n\nexport type Flatten<T extends unknown[]> = T extends [infer F, ...infer R] ? F | Flatten<R> : never;\n\nexport type Reverse<T extends unknown[]> = T extends [...infer R, infer L]\n  ? [L, ...Reverse<R>]\n  : [];\n\nexport type Unique<T extends unknown[]> = T extends [infer F, ...infer R]\n  ? F extends R[number]\n    ? never\n    : [F, ...Unique<R>]\n  : T;\n\nexport type Includes<T extends unknown[], U> = U extends T[number] ? true : false;\n\nexport type IncludesAll<T extends unknown[], U extends unknown[]> = U extends [infer F, ...infer R]\n  ? F extends T[number]\n    ? IncludesAll<T, R>\n    : false\n  : true;\n\nexport type IncludesAny<T extends unknown[], U extends unknown[]> = U extends [infer F, ...infer R]\n  ? F extends T[number]\n    ? true\n    : IncludesAny<T, R>\n  : false;\n\nexport type UnionIncludes<T, U> = [T] extends [never]\n  ? false\n  : T extends U\n    ? true\n    : U extends T\n      ? true\n      : false;\n\nexport type Last<T extends unknown[]> = T extends [...unknown[], infer L] ? L : never;\n\nexport type First<T extends unknown[]> = T extends [infer F, ...unknown[]] ? F : never;\n\nexport type Rest<T extends unknown[]> = T extends [unknown, ...infer R] ? R : never;\n\nexport type Init<T extends unknown[]> = T extends [unknown, ...infer R] ? R : T extends [] ? [] : T;\n\nexport type At<T extends unknown[], I extends number> = T extends [...Array<unknown>, infer E]\n  ? I extends keyof Init<T>\n    ? E\n    : never\n  : never;\n\nexport type AtLeastOne<T, U = { [K in keyof T]-?: T[K] }> = Partial<T> & U & Record<string, never>;\n\nexport type AllOrNone<T> = Partial<T> | { [K in keyof T]-?: T[K] };\n\nexport type OneOrMore<T> = T | T[];\n\nexport type ExactlyOne<T, K extends keyof T = keyof T> = {\n  [P in K]-?: T[P];\n} & {\n  [P in Exclude<keyof T, K>]?: never;\n} & {\n  [P in K]?: T[P];\n} & Record<string, never>;\n\nexport type XOR<T, U> = T | U extends object\n  ? (undefined extends T ? Record<string, never> : { [K in Exclude<keyof T, keyof U>]?: T[K] }) &\n      (undefined extends U ? Record<string, never> : { [K in Exclude<keyof U, keyof T>]?: U[K] })\n  : T | U;\n\nexport type NOR<T, U> = Exclude<Exclude<T, U>, U>;\n\nexport type NAND<T, U> = T extends U ? never : U extends T ? never : T | U;\n\nexport type OR<T, U> = T | U;\n\nexport type AND<T, U> = T & U;\n\nexport type NOT<T> = never extends T ? never : Exclude<T, never>;\n\nexport type XOR3<T, U, V> = XOR<T, XOR<U, V>>;\n\nexport type Tuple<T extends unknown[]> = {\n  [K in keyof T]: T[K];\n};\n\nexport type RecordKey<T> = T extends Record<infer K, unknown> ? K : never;\n\nexport type RecordValue<T> = T extends Record<string | number | symbol, infer V> ? V : never;\n\nexport type MapKey<T> = T extends Map<infer K, unknown> ? K : never;\n\nexport type MapValue<T> = T extends Map<unknown, infer V> ? V : never;\n\nexport type SetKey<T> = T extends Set<infer K> ? K : never;\n\nexport type PromiseKey<T> = T extends Promise<infer K> ? K : never;\n\nexport type ArrayKey<T> = T extends Array<infer K> ? K : never;\n\nexport type FunctionKey<T> = T extends (...args: unknown[]) => unknown ? T : never;\n\nexport type ObjectKey<T> = T extends object ? keyof T : never;\n\nexport type StringKey<T> = T extends string ? T : never;\n\nexport type NumberKey<T> = T extends number ? T : never;\n\nexport type BooleanKey<T> = T extends boolean ? T : never;\n\nexport type NullKey<T> = T extends null ? T : never;\n\nexport type UndefinedKey<T> = T extends undefined ? T : never;\n\nexport type VoidKey<T> = T extends void ? T : never;\n\nexport type AnyKey<T> = T extends unknown ? T : never;\n\nexport type UnknownKey<T> = T extends unknown ? T : never;\n\nexport type NeverKey<T> = T extends never ? T : never;\n\nexport type Primitive = string | number | boolean | bigint | symbol | null | undefined;\n\nexport type NonPrimitive = object;\n\nexport type Builtin = Primitive | ((...args: unknown[]) => unknown) | Date | Error | RegExp;\n\nexport type IsTuple<T> = T extends readonly unknown[]\n  ? number extends T['length']\n    ? false\n    : true\n  : false;\n\nexport type IsArray<T> = T extends unknown[] ? true : false;\n\nexport type IsObject<T> = T extends object\n  ? T extends (...args: unknown[]) => unknown\n    ? false\n    : T extends unknown[]\n      ? false\n      : true\n  : false;\n\nexport type IsFunction<T> = T extends (...args: unknown[]) => unknown ? true : false;\n\nexport type IsString<T> = T extends string ? true : false;\n\nexport type IsNumber<T> = T extends number ? true : false;\n\nexport type IsBoolean<T> = T extends boolean ? true : false;\n\nexport type IsNull<T> = T extends null ? true : false;\n\nexport type IsUndefined<T> = T extends undefined ? true : false;\n\nexport type IsNullable<T> = IsNull<T> extends true ? true : IsUndefined<T>;\n\nexport type IsOptional<T> = undefined extends T ? true : false;\n\nexport type IsRequired<T> = undefined extends T ? false : true;\n\nexport type IsReadonly<T> = T extends readonly unknown[] ? true : false;\n\nexport type IsMutable<T> = IsReadonly<T> extends true ? false : IsObject<T>;\n\nexport type IsDeepReadonly<T> = T extends DeepReadonly<unknown> ? true : false;\n\nexport type IsDeepMutable<T> = [T] extends [DeepMutable<unknown>] ? true : false;\n\nexport type IsExact<T, U> = Equals<T, U>;\n\nexport type IsSupertype<T, U> = T extends U ? true : false;\n\nexport type IsSubtype<T, U> = U extends T ? true : false;\n\nexport type IsAssignable<T, U> = [U] extends [T] ? true : false;\n\nexport type IsSame<T, U> = Equals<T, U>;\n\nexport type IsDifferent<T, U> = Equals<T, U> extends true ? false : true;\n\nexport type IsLiteral<T> = T extends Primitive\n  ? [T] extends [never]\n    ? false\n    : [T] extends [string | number | boolean | bigint | symbol | null | undefined]\n      ? T extends string | number | boolean | bigint | symbol | null | undefined\n        ? [string | number | boolean | bigint | symbol | null | undefined] extends [T]\n          ? false\n          : true\n        : false\n      : false\n  : false;\n\nexport type IsUnionLiteral<T, U> = [T] extends [U] ? false : [U] extends [T] ? false : true;\n\nexport type ExtractLiteral<T> = T extends Primitive\n  ? [T] extends [string | number | boolean | bigint | symbol | null | undefined]\n    ? [string | number | boolean | bigint | symbol | null | undefined] extends [T]\n      ? never\n      : T\n    : never\n  : never;\n\nexport type ExtractUnion<T> = T extends Primitive\n  ? [T] extends [string | number | boolean | bigint | symbol | null | undefined]\n    ? [string | number | boolean | bigint | symbol | null | undefined] extends [T]\n      ? T\n      : never\n    : never\n  : never;\n\nexport type ExtractObject<T> = T extends object\n  ? T extends (...args: unknown[]) => unknown\n    ? never\n    : T extends unknown[]\n      ? never\n      : T\n  : never;\n\nexport type ExtractArray<T> = T extends unknown[] ? T : never;\n\nexport type ExtractFunction<T> = T extends (...args: unknown[]) => unknown ? T : never;\n\nexport type ExtractPrimitive<T> = T extends Primitive ? T : never;\n\nexport type ExtractNonPrimitive<T> = T extends NonPrimitive ? T : never;\n\nexport type ExtractBuiltin<T> = T extends Builtin ? T : never;\n\nexport type ExtractNonBuiltin<T> = Builtin extends T ? never : T;\n\nexport type ExtractTuple<T> = T extends readonly unknown[]\n  ? number extends T['length']\n    ? never\n    : T\n  : never;\n\nexport type ExtractNonTuple<T> = T extends readonly unknown[]\n  ? number extends T['length']\n    ? T\n    : never\n  : never;\n\nexport type ExtractArrayNonTuple<T> = T extends unknown[]\n  ? number extends T['length']\n    ? T\n    : never\n  : never;\n\nexport type ExtractObjectNonArray<T> = T extends object\n  ? T extends (...args: unknown[]) => unknown\n    ? never\n    : T extends unknown[]\n      ? never\n      : T\n  : never;\n\nexport type ExtractFunctionNonObject<T> = T extends (...args: unknown[]) => unknown ? T : never;\n\nexport type ExtractPrimitiveNonObject<T> = T extends Primitive ? T : never;\n\nexport type ExtractNonPrimitiveNonObjectNonFunction<T> = T extends NonPrimitive\n  ? T extends (...args: unknown[]) => unknown\n    ? never\n    : T\n  : never;\n\nexport type ExtractBuiltinNonPrimitiveNonObjectNonFunction<T> = T extends Builtin\n  ? T extends Primitive\n    ? T\n    : never\n  : never;\n\nexport type ExtractNonBuiltinNonPrimitiveNonObjectNonFunction<T> = NonPrimitive extends T\n  ? T extends (...args: unknown[]) => unknown\n    ? never\n    : T\n  : never;\n\nexport type ExtractTupleNonArrayNonObjectNonFunction<T> = T extends readonly unknown[]\n  ? number extends T['length']\n    ? T\n    : never\n  : never;\n\nexport type ExtractNonTupleNonArrayNonObjectNonFunction<T> = T extends readonly unknown[]\n  ? number extends T['length']\n    ? T\n    : never\n  : never;\n\nexport type ExtractArrayNonTupleNonObjectNonFunction<T> = T extends unknown[]\n  ? number extends T['length']\n    ? T\n    : never\n  : never;\n\nexport type ExtractObjectNonArrayNonTupleNonFunction<T> = T extends object\n  ? T extends (...args: unknown[]) => unknown\n    ? never\n    : T extends unknown[]\n      ? never\n      : T\n  : never;\n\nexport type ExtractFunctionNonObjectNonArrayNonTuple<T> = T extends (...args: unknown[]) => unknown\n  ? T\n  : never;\n\nexport type ExtractPrimitiveNonObjectNonArrayNonTupleNonFunction<T> = T extends Primitive\n  ? T\n  : never;\n\nexport type ExtractNonPrimitiveNonObjectNonArrayNonTupleNonFunction<T> = T extends NonPrimitive\n  ? T extends (...args: unknown[]) => unknown\n    ? never\n    : T\n  : never;\n\nexport type ExtractBuiltinNonPrimitiveNonObjectNonArrayNonTupleNonFunction<T> = T extends Builtin\n  ? T extends Primitive\n    ? T\n    : never\n  : never;\n\nexport type ExtractNonBuiltinNonPrimitiveNonObjectNonArrayNonTupleNonFunction<T> =\n  NonPrimitive extends T ? (T extends (...args: unknown[]) => unknown ? never : T) : never;\n"],"mappings":";;AAAA;;;;;;;;AAAA;AAAA,SAAAA,eAAA;EAAA,IAAAC,IAAA;EAAA,IAAAC,IAAA;EAAA,IAAAC,MAAA,OAAAC,QAAA;EAAA,IAAAC,GAAA;EAAA,IAAAC,YAAA;IAAAL,IAAA;IAAAM,YAAA;MAAA;QAAAC,KAAA;UAAAC,IAAA;UAAAC,MAAA;QAAA;QAAAC,GAAA;UAAAF,IAAA;UAAAC,MAAA;QAAA;MAAA;IAAA;IAAAE,KAAA;IAAAC,SAAA;IAAAC,CAAA;MAAA;IAAA;IAAAC,CAAA;IAAAC,CAAA;IAAAC,cAAA;MAAAC,IAAA;MAAAC,QAAA;MAAAC,KAAA;MAAAC,OAAA;MAAAC,cAAA;MAAAC,OAAA;IAAA;IAAAC,eAAA;IAAAtB,IAAA;EAAA;EAAA,IAAAuB,QAAA,GAAAtB,MAAA,CAAAE,GAAA,MAAAF,MAAA,CAAAE,GAAA;EAAA,KAAAoB,QAAA,CAAAxB,IAAA,KAAAwB,QAAA,CAAAxB,IAAA,EAAAC,IAAA,KAAAA,IAAA;IAAAuB,QAAA,CAAAxB,IAAA,IAAAK,YAAA;EAAA;EAAA,IAAAoB,cAAA,GAAAD,QAAA,CAAAxB,IAAA;EAAA","ignoreList":[]}